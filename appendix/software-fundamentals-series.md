# Software Fundamentals Series

## 1. Overview

This is a three-part series that builds a fundamental approach to designing, implementing, and analyzing complex algorithms. The course also incorporates key skills including technical communication and collaboration while problem solving. The course is designed to provide students with the techniques and confidence required to solve especially challenging technical problems.

A key part of the course series is frequent, quantitative assessment that demonstrates progress and helps students calibrate and focus their efforts.

* **Audience:** Undergraduate CS students across all 4 years
* **Goal:** Develop strong confidence and readiness in the fundamentals of solving technical problems including analysis, debugging, verification and technical communication
* **Outcomes:** Student is confident and ready to succeed in technical interviewing and engaging in complex problem solving

Section 2 below covers the audience, goal, and outcome of each 12-week course. Section 3 reviews the schedule of topics and the progression of difficulty within a topic. Section 4 reviews the learning goals that span topics. Finally, section 5 reviews the assessment framework that we use to benchmark student progress across multiple dimensions.

## 2. Course Series

The course series is designed for freshmen through seniors, although students test into the appropriate level. For example, it might be appropriate for a sophomore to take the advanced class and a junior to take the intermediate class.

### 2.1. Structure

Each of the 3 courses in the series is structured as follows:

* Semester-long course with two sessions each week
* Instructor-led in-class activities focused on specific elements of problem solving
* Small group activities where students solve problems together and discuss solutions
* At-home warmup exercises which prepare students for the sessions
* Weekly coding tests designed to evaluate students across six key aspects of mastery
* Detailed expert walkthrough videos to model a robust framework for problem solving
* Technical guides documenting specific algorithmic patterns and techniques

### 2.2. Series Breakdown

The audience, goals, and outcomes for our software fundamentals series are outlined below:

1. **SE101: Introduction to Software Fundamentals**
   * Audience: Freshman/Sophomore CS & STEM w/ basic programming experience
   * Goal: Practical techniques for designing and implementing basic algorithms \(UMPIRE\)
   * Outcome: **Clear understanding of technical interviewing, follow-through to SE102**
2. **SE102: Intermediate Software Fundamentals**
   * Audience: Sophomore/Junior CS w/ data structures and algorithms experience
   * Goal: Improve student proficiency and confidence in algorithmic techniques and analysis
   * Outcome: **Pass technical phone screens at companies, and pass technical on-sites in easier-to-medium interview cycles**
3. **SE103: Advanced Software Fundamentals**
   * Audience: Junior/Senior CS w/ data structures and algorithms experience
   * Goal: Empower students with the confidence and knowledge to excel at top tech companies
   * Outcome: **Pass technical on-sites in medium-to-hard interview cycles**

### 2.3. Pedagogy

In these courses, students are introduced to the following:

* The [UMPIRE method](https://guides.codepath.com/compsci/UMPIRE-Interview-Strategy) which is a comprehensive framework for solving technical problems every step of the way from designing the algorithm, to checking the test cases.
* A framework for complexity analysis that allows students to make trade-offs between time and space
* A structured approach to "talking out loud while they solve problems" which is a crucial component to successful interviewing by practicing a high number of problems with other students and mentors over 12-weeks
* Deep explorations of fundamentals and techniques encountered in technical interviews or while developing algorithms. Check [this guide for a sample of topics](https://guides.codepath.com/compsci).

Check out our [passing the technical interview](https://tinyurl.com/codepathinterviewguide) guide for a high-level of the things covered across our rigorous three-part series including behavioral tips, and technical topics.

## 3. Topics

Spanning our three-part software fundamentals series, the following topics will be reviewed across three levels of difficulty:

| Topic | SE101 | SE102 | SE103 |
| :--- | :--- | :--- | :--- |
| Loops | âšª |  |  |
| Conditionals | âšª |  |  |
| Hashtables | âšª | ðŸ”µ | ðŸ”´ |
| Strings | âšª | ðŸ”µ | ðŸ”´ |
| Arrays | âšª | ðŸ”µ | ðŸ”´ |
| Linked Lists |  | âšª ðŸ”µ | ðŸ”´ |
| Stacks and Queues |  | âšª | ðŸ”µ |
| Trees and Binary Trees |  | âšª ðŸ”µ | ðŸ”´ |
| Graphs |  | âšª | ðŸ”µ |
| Greedy Algorithms |  |  | âšª ðŸ”µ |
| Dynamic Programming |  |  | âšª ðŸ”µ |
| Backtracking |  |  | âšª ðŸ”µ |

{% hint style="info" %}
**Legend:** âšª Easy ðŸ”µ Medium ðŸ”´ Hard
{% endhint %}

## 4. Learning Goals

Spanning our three-part software fundamentals series, students should develop increasing proficiency and confidence across the following learning goals:

1. Comprehend problem and develop a set of test cases with expected outputs.
2. Select appropriate abstract data types and algorithms for use in a given application.
3. Design and implement required operations including traversal, insertion, deletion, search, and sort.
4. Decompose proposed solution through use of visualization and pseudocode.
5. Trace through and predict the behavior of code designed to implement required operations. 
6. Identify and remedy flaws in an implementation that may cause its behavior to differ from the intended design. 
7. Analyze runtime efficiency and space complexity of algorithms.

The learning goals above are adapted from: [Developing Course-Level Learning Goals for Basic Data Structures in CS2](https://www.cs.oberlin.edu/~ctaylor/pubs/p858-porter.pdf).

## 5. Assessment Framework

The assessment framework enables us to accurately evaluate student skill levels and personalize their growth plans. Each course involves weekly assessments and scores across each area below:

* **Algorithms** - Deciding and defining algorithms
* **Design** - Object-oriented and system design
* **Coding** - Implementing algorithms into running code
* **Analysis** - Time/space complexity analysis, trade-off analysis
* **Verification/Debugging** - Diagnosing edge cases, and tracing test cases
* **Technical Communication** - Writing and speaking about code and projects

We work with students to reinforce, develop and measure all six areas throughout our software fundamentals series.

